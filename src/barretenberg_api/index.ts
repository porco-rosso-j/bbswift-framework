// WARNING: FILE CODE GENERATED BY BINDGEN UTILITY. DO NOT EDIT!
/* eslint-disable @typescript-eslint/no-unused-vars */
import {
	BufferDeserializer,
	NumberDeserializer,
	VectorDeserializer,
	BoolDeserializer,
	StringDeserializer,
	serializeBufferable,
	OutputType,
} from "../serialize/index.js";
import { Fr, Fq, Point, Buffer32, Buffer128, Ptr } from "../types/index.js";
import { NativeModules } from "react-native";
const { BBSwiftModule } = NativeModules;

/*
[TypeError: undefined is not an object (evaluating '(0, _$$_REQUIRE(_dependencyMap[9], "tslib").__classPrivateFieldGet)(_this, _EntrypointPayload_packedArguments, "f")[index].hash')]
*/
export class BarretenbergApi {
	async pedersenCommit(inputsBuffer: Fr[]): Promise<Point> {
		// console.log("pedersenCommit called");
		// console.log('inputsBuffer: ', inputsBuffer);
		const initArgs = inputsBuffer.flatMap((f) => Array.from(f.toBuffer()));
		// console.log('initArgs: ', initArgs);
		const resultBuffer = await BBSwiftModule.pedersenCommit(initArgs);
		// console.log('resultBuffer: ', resultBuffer);
		if (!resultBuffer) {
			throw new Error("pedersenCommit returned null or encountered an error");
		}
		return Point.fromBuffer(resultBuffer);
	}

	async pedersenHash(inputsBuffer: Fr[], hashIndex: number): Promise<Fr> {
		// console.log("pedersenHash called");
		// console.log('inputsBuffer: ', inputsBuffer);
		const initArgs = inputsBuffer.flatMap((f) => Array.from(f.toBuffer()));
		// console.log('initArgs: ', initArgs);
		const resultBuffer = await BBSwiftModule.pedersenHash(initArgs, hashIndex);
		// console.log('resultBuffer: ', resultBuffer);
		if (!resultBuffer) {
			throw new Error("pedersenHash returned null or encountered an error");
		}
		return Fr.fromBuffer(resultBuffer);
	}

	async poseidon2Hash(inputsBuffer: Fr[]): Promise<Fr> {
		// console.log("poseidon2Hash called");
		// console.log('inputsBuffer: ', inputsBuffer);
		const initArgs = inputsBuffer.flatMap((f) => Array.from(f.toBuffer()));
		// console.log('initArgs: ', initArgs);
		const resultBuffer = await BBSwiftModule.poseidon2Hash(initArgs);
		// console.log('resultBuffer: ', resultBuffer);
		if (!resultBuffer) {
			throw new Error("poseidon2Hash returned null or encountered an error");
		}
		return Fr.fromBuffer(resultBuffer);
	}

	async eccGrumpkinMul(pointBuf: Buffer, scalarBuf: Buffer): Promise<Buffer> {
		// console.log("eccGrumpkinMul called");
		// console.log("pointBuf: ", pointBuf);
		// console.log("scalarBuf: ", scalarBuf);

		const resultBuffer = await BBSwiftModule.eccGrumpkinMul(
			Array.from(pointBuf),
			Array.from(scalarBuf)
		);
		// console.log("resultBuffer: ", resultBuffer);
		if (!resultBuffer) {
			throw new Error("eccGrumpkinMul returned null or encountered an error");
		}
		// return Point.fromBuffer(resultBuffer);
		return Buffer.from(resultBuffer);
	}

	async eccGrumpkinAdd(pointABuf: Buffer, pointBBuf: Buffer): Promise<Buffer> {
		// console.log("eccGrumpkinAdd called");
		// console.log("pointABuf: ", pointABuf);
		// console.log("pointBBuf: ", pointBBuf);
		const resultBuffer = await BBSwiftModule.eccGrumpkinAdd(
			Array.from(pointABuf),
			Array.from(pointBBuf)
		);
		// console.log("resultBuffer: ", resultBuffer);
		if (!resultBuffer) {
			throw new Error("eccGrumpkinAdd returned null or encountered an error");
		}
		return Buffer.from(resultBuffer);
	}
	async pedersenHashes(inputsBuffer: Fr[], hashIndex: number): Promise<Fr> {
		throw new Error("pedersenHashes not supported");
	}

	async pedersenHashBuffer(
		inputBuffer: Uint8Array,
		hashIndex: number
	): Promise<Fr> {
		throw new Error("pedersenHashBuffer not supported");
	}

	async poseidon2Hashes(inputsBuffer: Fr[]): Promise<Fr> {
		throw new Error("poseidon2Hashes not supported");
	}

	async poseidon2Permutation(inputsBuffer: Fr[]): Promise<Fr[]> {
		throw new Error("poseidon2Permutation not supported");
	}

	async blake2s(data: Uint8Array): Promise<Buffer32> {
		throw new Error("blake2s not supported");
	}

	async blake2sToField(data: Uint8Array): Promise<Fr> {
		throw new Error("blake2sToField not supported");
	}

	async schnorrComputePublicKey(privateKey: Fr): Promise<Point> {
		throw new Error("schnorrComputePublicKey not supported");
	}

	async schnorrNegatePublicKey(publicKeyBuffer: Point): Promise<Point> {
		throw new Error("schnorrNegatePublicKey not supported");
	}

	async schnorrConstructSignature(
		message: Uint8Array,
		privateKey: Fr
	): Promise<[Buffer32, Buffer32]> {
		throw new Error("schnorrConstructSignature not supported");
	}

	async schnorrVerifySignature(
		message: Uint8Array,
		pubKey: Point,
		sigS: Buffer32,
		sigE: Buffer32
	): Promise<boolean> {
		throw new Error("schnorrVerifySignature not supported");
	}

	async schnorrMultisigCreateMultisigPublicKey(
		privateKey: Fq
	): Promise<Buffer128> {
		throw new Error("schnorrMultisigCreateMultisigPublicKey not supported");
	}

	async schnorrMultisigValidateAndCombineSignerPubkeys(
		signerPubkeyBuf: Buffer128[]
	): Promise<[Point, boolean]> {
		throw new Error(
			"schnorrMultisigValidateAndCombineSignerPubkeys not supported"
		);
	}

	async schnorrMultisigConstructSignatureRound1(): Promise<
		[Buffer128, Buffer128]
	> {
		throw new Error("schnorrMultisigConstructSignatureRound1 not supported");
	}

	async schnorrMultisigConstructSignatureRound2(
		message: Uint8Array,
		privateKey: Fq,
		signerRoundOnePrivateBuf: Buffer128,
		signerPubkeysBuf: Buffer128[],
		roundOnePublicBuf: Buffer128[]
	): Promise<[Fq, boolean]> {
		throw new Error("schnorrMultisigConstructSignatureRound2 not supported");
	}

	async schnorrMultisigCombineSignatures(
		message: Uint8Array,
		signerPubkeysBuf: Buffer128[],
		roundOneBuf: Buffer128[],
		roundTwoBuf: Fq[]
	): Promise<[Buffer32, Buffer32, boolean]> {
		throw new Error("schnorrMultisigCombineSignatures not supported");
	}

	async aesEncryptBufferCbc(
		input: Uint8Array,
		iv: Uint8Array,
		key: Uint8Array,
		length: number
	): Promise<Uint8Array> {
		throw new Error("aesEncryptBufferCbc not supported");
	}

	async aesDecryptBufferCbc(
		input: Uint8Array,
		iv: Uint8Array,
		key: Uint8Array,
		length: number
	): Promise<Uint8Array> {
		throw new Error("aesDecryptBufferCbc not supported");
	}

	async srsInitSrs(
		pointsBuf: Uint8Array,
		numPoints: number,
		g2PointBuf: Uint8Array
	): Promise<void> {
		throw new Error("srsInitSrs not supported");
	}

	async srsInitGrumpkinSrs(
		pointsBuf: Uint8Array,
		numPoints: number
	): Promise<void> {
		throw new Error("srsInitGrumpkinSrs not supported");
	}

	async examplesSimpleCreateAndVerifyProof(): Promise<boolean> {
		throw new Error("examplesSimpleCreateAndVerifyProof not supported");
	}

	async testThreads(threads: number, iterations: number): Promise<number> {
		throw new Error("testThreads not supported");
	}

	async commonInitSlabAllocator(circuitSize: number): Promise<void> {
		throw new Error("commonInitSlabAllocator not supported");
	}

	async acirGetCircuitSizes(
		constraintSystemBuf: Uint8Array,
		honkRecursion: boolean
	): Promise<[number, number, number]> {
		throw new Error("acirGetCircuitSizes not supported");
	}

	async acirNewAcirComposer(sizeHint: number): Promise<Ptr> {
		throw new Error("acirNewAcirComposer not supported");
	}

	async acirDeleteAcirComposer(acirComposerPtr: Ptr): Promise<void> {
		throw new Error("acirDeleteAcirComposer not supported");
	}

	async acirCreateCircuit(
		acirComposerPtr: Ptr,
		constraintSystemBuf: Uint8Array,
		sizeHint: number
	): Promise<void> {
		throw new Error("acirCreateCircuit not supported");
	}

	async acirInitProvingKey(
		acirComposerPtr: Ptr,
		constraintSystemBuf: Uint8Array
	): Promise<void> {
		throw new Error("acirInitProvingKey not supported");
	}

	async acirCreateProof(
		acirComposerPtr: Ptr,
		constraintSystemBuf: Uint8Array,
		witnessBuf: Uint8Array
	): Promise<Uint8Array> {
		throw new Error("acirCreateProof not supported");
	}

	async acirProveAndVerifyUltraHonk(
		constraintSystemBuf: Uint8Array,
		witnessBuf: Uint8Array
	): Promise<boolean> {
		throw new Error("acirProveAndVerifyUltraHonk not supported");
	}

	async acirProveAndVerifyMegaHonk(
		constraintSystemBuf: Uint8Array,
		witnessBuf: Uint8Array
	): Promise<boolean> {
		throw new Error("acirProveAndVerifyMegaHonk not supported");
	}

	async acirFoldAndVerifyProgramStack(
		constraintSystemBuf: Uint8Array,
		witnessBuf: Uint8Array
	): Promise<boolean> {
		throw new Error("acirFoldAndVerifyProgramStack not supported");
	}

	async acirLoadVerificationKey(
		acirComposerPtr: Ptr,
		vkBuf: Uint8Array
	): Promise<void> {
		throw new Error("acirLoadVerificationKey not supported");
	}

	async acirInitVerificationKey(acirComposerPtr: Ptr): Promise<void> {
		throw new Error("acirInitVerificationKey not supported");
	}

	async acirGetVerificationKey(acirComposerPtr: Ptr): Promise<Uint8Array> {
		throw new Error("acirGetVerificationKey not supported");
	}

	async acirGetProvingKey(
		acirComposerPtr: Ptr,
		acirVec: Uint8Array
	): Promise<Uint8Array> {
		throw new Error("acirGetProvingKey not supported");
	}

	async acirVerifyProof(
		acirComposerPtr: Ptr,
		proofBuf: Uint8Array
	): Promise<boolean> {
		throw new Error("acirVerifyProof not supported");
	}

	async acirGetSolidityVerifier(acirComposerPtr: Ptr): Promise<string> {
		throw new Error("acirGetSolidityVerifier not supported");
	}

	async acirSerializeProofIntoFields(
		acirComposerPtr: Ptr,
		proofBuf: Uint8Array,
		numInnerPublicInputs: number
	): Promise<Fr[]> {
		throw new Error("acirSerializeProofIntoFields not supported");
	}

	async acirSerializeVerificationKeyIntoFields(
		acirComposerPtr: Ptr
	): Promise<[Fr[], Fr]> {
		throw new Error("acirSerializeVerificationKeyIntoFields not supported");
	}

	async acirProveUltraHonk(
		acirVec: Uint8Array,
		witnessVec: Uint8Array
	): Promise<Uint8Array> {
		throw new Error("acirProveUltraHonk not supported");
	}

	async acirVerifyUltraHonk(
		proofBuf: Uint8Array,
		vkBuf: Uint8Array
	): Promise<boolean> {
		throw new Error("acirVerifyUltraHonk not supported");
	}

	async acirWriteVkUltraHonk(acirVec: Uint8Array): Promise<Uint8Array> {
		throw new Error("acirWriteVkUltraHonk not supported");
	}

	async acirProofAsFieldsUltraHonk(proofBuf: Uint8Array): Promise<Fr[]> {
		throw new Error("acirProofAsFieldsUltraHonk not supported");
	}

	async acirVkAsFieldsUltraHonk(vkBuf: Uint8Array): Promise<Fr[]> {
		throw new Error("acirVkAsFieldsUltraHonk not supported");
	}
}
